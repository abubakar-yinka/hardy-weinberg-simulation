[{"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\index.js":"1","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\reportWebVitals.js":"2","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\App.js":"3","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\LineChart.js":"4","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\hooks\\useD3.js":"5","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\components\\SpatialModels.js":"6","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\grids\\DrawGrid.js":"7","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\grids\\UpdateGrid.js":"8"},{"size":500,"mtime":1607601820706,"results":"9","hashOfConfig":"10"},{"size":362,"mtime":1607601820706,"results":"11","hashOfConfig":"10"},{"size":9924,"mtime":1608386400199,"results":"12","hashOfConfig":"10"},{"size":6206,"mtime":1607818896684,"results":"13","hashOfConfig":"10"},{"size":295,"mtime":1607797058078,"results":"14","hashOfConfig":"10"},{"size":5927,"mtime":1608553874185,"results":"15","hashOfConfig":"10"},{"size":1493,"mtime":1608495638785,"results":"16","hashOfConfig":"10"},{"size":784,"mtime":1608496045566,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"tyhnbo",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"28"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"20"},"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\index.js",[],["39","40"],"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\reportWebVitals.js",[],"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\App.js",["41","42","43"],"// import logo from './logo.svg';\nimport './App.css';\n// import LineChart from './LineChart';\nimport SpatialModels from './components/SpatialModels'\n\n// // 1. Initialising the genotype frequencies\n// let a1a1 = 0.15;\n// let a2a2 = 0.35;\n// let a1a2 = 1 - (a1a1 + a2a2);\n\n// //Calculating the allele frequencies based on the genotype frequencies where p = f(A1), q = f(A2)\n// const p = a1a1 + (a1a2 / 2);\n// const q = 1 - p;\n\n// console.log(`Generation 0 => a1a1: ${a1a1}, a2a2: ${a2a2}, a1a2: ${a1a2}, p: ${p}, q: ${q}`);\n\n//Rounding a number to a specified number of digits after the decimal pt of the value\n// const round_number = (value, decimals) => {\n//   const exponent_calculator = Math.pow(10, decimals)\n//   return Math.round(value * exponent_calculator) / exponent_calculator;\n// }\n\n// //Calculating the genotype frequencies for the next generations based on the allele frequencies\n// const create_next_generation = (generation_number) => {\n//   a1a1 = p * p;\n//   a1a2 = 2 * p * q;\n//   a2a2 = q * q;\n\n//   console.log(`Generation ${generation_number} => a1a1: ${round_number(a1a1, 2)}, a2a2: ${round_number(a2a2, 2)}, a1a2: ${round_number(a1a2, 2)}, p: ${p}, q: ${q}`);\n// };\n// for(let i = 0; i < 5; i++) {\n//   create_next_generation(i + 1);\n// };\n\n// 2. \n// let p;\n// let q = 0.5;\n// let N = 100000;\n// const generations = 100;\n// const simulations = 10;\n// const data = [];\n// const pop_sizes = [];\n\n// //Calculate the next Generation using a generic next generation function to demonstrate genetic drift\n// const next_generation = (simulation_array, current_N) => {\n//   const draws = 2 * current_N;\n//   let a1 = 0;\n//   let a2 = 0;\n//   for (let i = 0; i < draws; i++) {\n//     if (Math.random() <= p) {\n//       a1 += 1;\n//     } else {\n//       a2 += 1;\n//     }\n//   }\n//   //Calculate the new allele frequencies\n//   p = a1 / draws;\n//   q = a2 / draws\n//   simulation_array.push(p);\n// }\n\n// //Calling the next generation function to create a new generation 1000x\n// const simulation = (simulation_index) => {\n//   p = 0.5;\n//   let pop_size;\n//   for (let i = 0; i < generations; i++) {\n//     //Implementing the bottleneck for every 10th gen(i % 10)\n//     if (i % 10 === 9) {\n//       pop_size = 10;\n//     } else {\n//       pop_size = N;\n//     }\n\n//     pop_sizes.push(pop_size);\n//     next_generation(data[simulation_index], pop_size);\n//     console.log(`The value of p and q in generation ${i} is ${round_number(p, 4)} and ${round_number(q, 4)}`);\n//   }\n// }\n\n// //Using a loop to call the simulation function 10x\n// for (let i = 0; i < simulations; i++) {\n//   data.push([]);\n//   simulation(i);\n// }\n\n// //Calculate the harmonic mean of these set of numbers(population sizes) using a function\n// const effective_pop_size = (all_pop_sizes) => {\n//   let denominator = 0;\n//   //Iterate over all the elements of the array provided in the argument and add the inverse of all the items to the denominator\n//   for (let i = 0; i < all_pop_sizes.length; i++) {\n//     let inverse_element = 1 / all_pop_sizes[i];\n//     denominator += inverse_element;\n//   }\n  \n//   return Math.round(all_pop_sizes.length / denominator);\n// }\n\n// //The effective population size\n// const Ne = effective_pop_size(pop_sizes);\n// console.log(`Ne is ${Ne}`);\n\n\n//-------------------------------\n\n// // 3. Coin Flipper Demonstration\n// const repeat = 1000;\n// let sum = 0;\n// for (let i = 0; i < repeat; i++) {\n//   sum = sum + Math.random();  \n// }\n// const average = sum / repeat;\n// console.log(`The average is ${average}`);\n\n// //The probability of throwing 10 coins and resulting to exactly 2 tails \n// const coin_tosser = () => {\n//   const coins = 10;\n//   let heads = 0;\n//   let tails = 0;\n\n//   for (let i = 0; i < coins; i++) {\n//     //The fact that each number btw 0 and 1 comes up with equal probability can be used to generate a fair coin i.e equal probability of heads and tails(0.5)\n//     if (Math.random() <= 0.5) {\n//       heads += 1;\n//     } else { \n//       tails += 1;\n//     }\n//   }\n\n//   if (heads === 8) {\n//     return true;\n//   } else {\n//     return false;\n//   }\n  \n// }\n// //Calling the coin tosser function to know how many times 8 heads came up when the coin was tossed 10 times\n// // const repeats = 10000000;\n// const repeats = 100000;\n// let counter = 0;\n// for (let i = 0; i < repeats; i++) {\n//     const desired_outcome = coin_tosser();\n//     if (desired_outcome) {\n//       counter += 1;\n//     }\n// }\n// console.log(`Getting 8 heads and 2 tails, ${(counter/repeats) * 100}% of the time`);\n\n//-------------------------------  \n\n//4. (Generating DNA Sequences) Implementing the idea of having multiple dna sequences that changes over time due to random mutation\nconst no_of_sequences = 100;\nconst sequence_length = 20;\nconst original_dna_sequence = [];\n//The sequences array is a 2 dimensional array which contains a set of arrays which all contain identical 20-base long dna sequences. They are all identical because we don't want genetic variation\nconst sequences = []; //Population: which is basically a 2-D array that holds a 100 other sequences which are also arrays and each sequence belongs to a simplified person\nconst no_of_generations = 100;\nconst mutation_rate = 0.0001; //Per base and generation\n\nconst bases = ['A', 'G', 'C', 'T'];\n\n//To generate the first generation/Population of a 100 people(100 dna sequences)\nconst generate_first_generation = () => {\n  generate_first_sequence();\n  for (let i = 0; i < no_of_sequences; i++) {\n      //Return a copy of the original array using slice method and push into the sequences array\n    sequences.push(original_dna_sequence.slice()); \n  }\n}\n\n//To generate the first original dna sequence 20bases long\nconst generate_first_sequence = () => {\n  for (let i = 0; i < sequence_length; i++) {\n    original_dna_sequence.push(generate_random_base(\"\"));\n  }\n}\n\n//Returns a random base(A, G, C, T) using math random(returns a number btw 0 and 1 but not including 1) and math floor(to round down) to generate the index which will be used to access a random base.\nconst generate_random_base = (current_base) => {\n  let new_base;\n  do {\n    const index = Math.floor(Math.random() * 4);\n    new_base = bases[index];\n  } while (new_base === current_base);\n  return new_base;\n}\n\nconst print_sequences = (title) => {\n  console.log(title)\n  for (let i = 0; i < no_of_sequences; i++) {\n    print_sequence(sequences[i]);\n  }\n  console.log(\"\")\n}\n\nconst print_sequence = sequence => {\n  let sequence_string = \"\"\n  for (let i = 0; i < sequence.length; i++) {\n    sequence_string += sequence[i];\n  }\n  console.log(sequence_string)\n}\n\n//change the bases in those dna strings with a certain rate called mutation rate i.e introduce some random modifications in those dna sequences, using a 3 fold nested loop in a function\nconst run_generations = () => {\n  for (let i = 0; i < no_of_generations; i++) {\n    //Each generation, go through all the sequences and within each sequence, go through all the bases and occasionally change a random base.\n    for (let ii = 0; ii < sequences.length; ii++) {\n      //Going through each sequence\n      for (let iii = 0; iii < sequences[ii].length; iii++) {\n        //going through each base to change a base randomly\n        //This should happen with a certain rate/probability which is the mutation rate that is 1 in 10000\n          if (Math.random() < mutation_rate) {\n            sequences[ii][iii] = generate_random_base(sequences[ii][iii]); //accessing the element of a 2-D array\n          } \n      }\n    }\n  }\n};\n\n// const N = 100\n// let p;\n// const simulations = 10000;\n// let fixations_of_mutants = 0;\n// let generations_that_went_to_fixation = 0\n\n// const next__generation = () => {\n//   const draws = 2 * N;\n//   let a1 = 0;\n//   let a2 = 0;\n//   for (let i = 0; i < draws; i++) {\n//       if (Math.random() <= p) {\n//         a1 += 1;\n//       } else {\n//         a2 += 1;\n//       }\n//   }\n//   p = a1 / draws \n// }\n\n// const run_until_fixation = () => {\n//   p = 1 / (2 * N); //freq of one single a1 allele at the beginning\n//   let generation_no = 0; //To keep track of the number of generations in each simulation run\n//   //If p = 0 or 1, it means that either the a1 has been lost and a2 has gone into fixation or vice versa\n//   do {\n//     next__generation();\n//     generation_no += 1;\n//   } while (p > 0 && p < 1);\n//   //How often p goes to 1 i.e fixation\n//   if (p === 1) {\n//     fixations_of_mutants += 1;\n//     generations_that_went_to_fixation = generations_that_went_to_fixation + generation_no\n//   }\n// }\n\n// for (let i = 0; i < simulations; i++) {\n//   run_until_fixation();  \n// }\n// console.log(`${fixations_of_mutants / simulations} is the fraction of simulations or prob that a1 has gone to fixation which is mathematically 0.005`)\n//generations_that_went_to_fixation is the sum of all generations that was spent in oly those simulations where p === 1\n// console.log(`${generations_that_went_to_fixation / fixations_of_mutants} is the average no of generations it takes for the a1 allele to go to fixation and the expected average is 4N`)\n\n// generate_first_generation();\n// print_sequences(`Generaion 0`);\n// run_generations();\n// print_sequences(`After ${no_of_generations} generations`);\n\n\n// const legend = [\"Eff. Population Size:\", Ne, \"Generations:\", generations]\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {/* <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React.\n        </a>\n      </header>\n      <LineChart data={data} x_label=\"Generation\" y_label=\"p\" legend_values={legend}/> */}\n      <SpatialModels />\n    </div>\n  );\n}\n\nexport default App;\n","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\LineChart.js",[],["44","45"],"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\hooks\\useD3.js",["46","47"],"import React from 'react';\r\nimport * as d3 from 'd3';\r\n\r\nexport const useD3 = (renderChartFn, dependencies) => {\r\n    const ref = React.useRef();\r\n\r\n    React.useEffect(() => {\r\n        renderChartFn(d3.select(ref.current));\r\n        return () => {};\r\n      }, dependencies);\r\n    return ref;\r\n}","C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\components\\SpatialModels.js",[],"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\grids\\DrawGrid.js",[],"C:\\Users\\OT Ibrahim\\Desktop\\hardy-weinberg-simulation\\src\\grids\\UpdateGrid.js",["48"],"import React from 'react';\r\nimport * as d3 from 'd3';\r\n\r\nexport function UpdateGrid(data, colors) {\r\n    const grid_length = data.length;\r\n    d3.select('svg').selectAll('g')\r\n        .data(data)\r\n        .selectAll('rect')\r\n        .data(function (d) {\r\n          return d;\r\n        })\r\n        .attr('class',function(d) {\r\n          return d;\r\n        });\r\n    if (!colors) {\r\n    \td3.selectAll(\".A1A1\").style(\"fill\",\"#fff\");\r\n        d3.selectAll(\".A1A2\").style(\"fill\",\"#2176c9\");\r\n        d3.selectAll(\".A2A2\").style(\"fill\",\"#042029\");\r\n    }\r\n    else {\r\n        for (let i = 0; i < colors.length; i = i + 2) {\r\n            d3.selectAll(\".\"+colors[i]).style(\"fill\",colors[i+1]);\t\r\n        }\r\n    }\r\n    return (\r\n        <div>\r\n            <svg></svg>\r\n        </div>\r\n    )\r\n}\r\n",{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":162,"column":7,"nodeType":"55","messageId":"56","endLine":162,"endColumn":32},{"ruleId":"53","severity":1,"message":"57","line":187,"column":7,"nodeType":"55","messageId":"56","endLine":187,"endColumn":22},{"ruleId":"53","severity":1,"message":"58","line":204,"column":7,"nodeType":"55","messageId":"56","endLine":204,"endColumn":22},{"ruleId":"49","replacedBy":"59"},{"ruleId":"51","replacedBy":"60"},{"ruleId":"61","severity":1,"message":"62","line":10,"column":10,"nodeType":"55","endLine":10,"endColumn":22},{"ruleId":"61","severity":1,"message":"63","line":10,"column":10,"nodeType":"55","endLine":10,"endColumn":22,"suggestions":"64"},{"ruleId":"53","severity":1,"message":"65","line":5,"column":11,"nodeType":"55","messageId":"56","endLine":5,"endColumn":22},"no-native-reassign",["66"],"no-negated-in-lhs",["67"],"no-unused-vars","'generate_first_generation' is assigned a value but never used.","Identifier","unusedVar","'print_sequences' is assigned a value but never used.","'run_generations' is assigned a value but never used.",["66"],["67"],"react-hooks/exhaustive-deps","React Hook React.useEffect was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.","React Hook React.useEffect has a missing dependency: 'renderChartFn'. Either include it or remove the dependency array. If 'renderChartFn' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["68"],"'grid_length' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"69","fix":"70"},"Update the dependencies array to be: [renderChartFn]",{"range":"71","text":"72"},[261,273],"[renderChartFn]"]